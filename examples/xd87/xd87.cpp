/**
 * 
  xd87.cpp   XD87 PCB interfaces of "Hobo-nicola keyboard and adapter library".
  Copyright (c) 2020-2023 Takeshi Higasa
  
  This file is part of "Hobo-nicola keyboard and adapter".

  "Hobo-nicola keyboard and adapter" is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  "Hobo-nicola keyboard and adapter" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Hobo-nicola keyboard and adapter".  If not, see <http://www.gnu.org/licenses/>.
  
  	hoboNicola 1.5.0.		Jul. 25. 2021.
		Initial version.
  	hoboNicola 1.6.4.		Feb. 1. 2023.
		Separating the xd64 common part.
*/

#include <avr/io.h>
#include <avr/wdt.h>
#include <Arduino.h>
#include "xd87.h"
#include "hid_keycode.h"

// 16000000 / 64 / 250 / 5 = 200(Hz) 
static const uint16_t TIMER1_INTERVAL = -250 * 5;  // 0xfb1d

// switch matrix info.
static const uint8_t ROW_COUNT = 6;
static const uint8_t COL_COUNT = 17;
static const uint8_t STATE_COUNT = ROW_COUNT * 3; // 24bits per row
static const uint8_t SW_COUNT = ROW_COUNT * COL_COUNT;	// 102 switch positions.
static uint8_t key_state[STATE_COUNT]; // current sw states.
static uint8_t last_key_state[STATE_COUNT];  // previous sw states.

// 
static void read_cols(uint8_t** pp) {
	uint8_t* p = *pp;    
	*p++ = ~( ((PINB << 2) & 0x80) | ((PINF >> 1) & 0x78) | ((PINF << 1) & 6) | ((PINE >> 6) & 1));
	*p++ = ~( ((PINB << 4) & 0xc0) | ((PINB << 1) & 0x20) | 
			((PIND >> 3) & 0x18) | ((PIND >> 2) & 4) | ((PINC >> 5) & 2) | ((PINB >> 6) & 1));
	*p = ~((PIND >> 2) & 1) & 1;
	*pp += 3;
}

#define READ_ROW(port, pin, pp)  { \
	port &= ~_BV(pin); \
	delayMicroseconds(5); \
	read_cols(pp); \
	port |= _BV(pin); \
	delayMicroseconds(5); }

/**
 * @brief The states of the switch is determined only when the results of two consecutive scans match. 
 * 			The code is generated by comparing them with the stored last determined switch states.
 */
void matrix_scan() {
	static uint8_t tmp_state[STATE_COUNT];
	cli();
	// read current sw stetes and store.
	uint8_t *p = tmp_state;
	READ_ROW(PORTD, 1, &p);
	READ_ROW(PORTB, 0, &p);
	READ_ROW(PORTB, 1, &p);
	READ_ROW(PORTC, 7, &p);
	READ_ROW(PORTD, 3, &p);
	READ_ROW(PORTD, 5, &p);
	sei();
	int n = memcmp(tmp_state, key_state, STATE_COUNT);
	if (n != 0) { // sw states not match. save current states for next time.
		memcpy(key_state, tmp_state, sizeof(tmp_state));
		return;
	}
	uint8_t code = 1;
	uint8_t m = 0;
	for(uint8_t i = 0; i < sizeof(tmp_state); i++) {
		uint8_t pressed = tmp_state[i];
		uint8_t delta;
		if (m == 2) {
			m = 0;
			delta = 1;
		} else {
			m++;
			delta = 8;
		}
		uint8_t change = pressed ^ last_key_state[i];
		if (change) {
			uint8_t mask = 1;
			for(uint8_t k = 0; k < delta; k++, mask <<= 1) {
				if (change & mask) {
				uint8_t c = code + k;
				c |= (pressed & mask) ? 0 : 0x80; // release なら 0x80をOR.
				xd_put_buffer(c);
				}
			}
			last_key_state[i] = pressed;  
		}
		code += delta;
	}
}

// TC1 interval interrupt service routine.
ISR(TIMER1_OVF_vect, ISR_NOBLOCK) {
	matrix_scan();
	TCNT1 = TIMER1_INTERVAL;
}

// scancode --> HID UsageID
// usageid = hid_table[][ scancode - 1 ];
static const uint8_t HID_TABLE_BASE = 0;
static const uint8_t HID_TABLE_FN1 = 1;
static const uint8_t scan_to_hid_table[2][SW_COUNT] = {
  {
		HID_ESCAPE,   HID_UNDEF,   HID_F1,    HID_F2,      HID_F3,       HID_F4,      HID_F5,       HID_F6,      HID_F7,     HID_F8,			//sw1-10
		HID_F9,       HID_F10,     HID_F11,   HID_F12,     HID_PRNTSCRN, HID_SCRLOCK, HID_PAUSE,    HID_ZENHAN,  HID_1,      HID_2,				//sw11-20
		HID_3,        HID_4,       HID_5,     HID_6,       HID_7,        HID_8,       HID_9,        HID_0,       HID_MINUS,  HID_EQUALS,	//sw21-30
		HID_J_BSLASH, HID_INSERT,  HID_HOME,  HID_PGUP,    HID_TAB,      HID_Q,       HID_W,        HID_E,       HID_R,      HID_T,				//sw31-40
		HID_Y,        HID_U,       HID_I,     HID_O,       HID_P,        HID_LBRACK,  HID_RBRACK,   HID_J_RBR_32,HID_DELETE, HID_END, 		//sw41-50
		HID_PGDOWN,   HID_IME_OFF, HID_A,     HID_S,       HID_D,        HID_F,       HID_G,        HID_H,       HID_J,      HID_K, 			//sw51-60
		HID_L,        HID_SEMICOL, HID_QUOTE, HID_UNDEF,   HID_ENTER,    HID_BACKSP,  HID_UNDEF,    HID_UNDEF,   HID_L_SHIFT,HID_UNDEF,		//sw61-70
		HID_Z,        HID_X,       HID_C,     HID_V,       HID_B,        HID_N,       HID_M,        HID_COMMA,   HID_PERIOD, HID_SLASH, 	//sw71-80
		HID_J_UL,     HID_R_SHIFT, HID_UNDEF, HID_U_ARROW, HID_UNDEF,    HID_L_CTRL,  HID_L_GUI,    HID_L_ALT,   HID_UNDEF,  HID_UNDEF,		//sw81-90
		HID_MUHENKAN, HID_UNDEF,   HID_UNDEF, HID_SPACE,   HID_UNDEF,    HID_HIRAGANA,HID_R_ALT,    HID_X_FN1,   HID_R_CTRL, HID_L_ARROW,	//sw91-100
		HID_D_ARROW, HID_R_ARROW	//sw101,102	
  },
 {     
		HID_ESCAPE,   HID_UNDEF,   HID_F13,   HID_F14,     HID_F15,      HID_F16,     HID_F17,      HID_F18,      HID_F19,      HID_F20,
		HID_F21,      HID_F22,     HID_F23,   HID_F24,     HID_PRNTSCRN, HID_SCRLOCK, HID_PAUSE,    HID_ZENHAN,   HID_1,        HID_2,
		HID_3,        HID_4,       HID_5,     HID_6,       HID_7,        HID_8,       HID_9,        HID_0,        HID_MINUS,    HID_EQUALS,
		HID_J_BSLASH, HID_INSERT,  HID_HOME,  HID_PGUP,    HID_TAB,      HID_Q,       HID_W,        HID_E,        HID_R,        HID_T,
		HID_Y,        HID_U,       HID_I,     HID_O,       HID_P,        HID_LBRACK,  HID_RBRACK,   HID_J_RBR_32, HID_DELETE,   HID_END, 
		HID_PGDOWN,   HID_CAPS,    HID_A,     HID_S,       HID_D,        HID_F,       HID_G,        HID_H,        HID_J,        HID_K, 
		HID_L,        HID_SEMICOL, HID_QUOTE, HID_UNDEF,   HID_ENTER,    HID_BACKSP,  HID_UNDEF,    HID_UNDEF,    HID_L_SHIFT,  HID_UNDEF,
		HID_Z,        HID_X,       HID_C,     HID_V,       HID_B,        HID_N,       FN_MEDIA_MUTE,FN_MEDIA_V_DN,FN_MEDIA_V_UP,HID_SLASH, 
		HID_APP,      HID_R_SHIFT, HID_UNDEF, HID_PGUP,    HID_UNDEF,    HID_L_CTRL,  HID_L_GUI,    HID_L_ALT,    HID_UNDEF,    HID_UNDEF,
		HID_SPACE,    HID_UNDEF,   HID_UNDEF, HID_HENKAN,  HID_UNDEF,    HID_IME_ON,  HID_R_ALT,    HID_X_FN1,    HID_R_CTRL,   HID_HOME,
		HID_PGDOWN,   HID_END
  }
};

static uint8_t hid_table_index = HID_TABLE_BASE;
void xd87_table_change(uint8_t key, bool pressed) {
	if (key == HID_X_FN1 && pressed)
		hid_table_index = HID_TABLE_FN1;
	else
		hid_table_index = HID_TABLE_BASE;
}

/**
 * us layout用のテーブルをもつほど相違はない。
*/
uint8_t xd87_get_key(bool& pressed, bool us_layout) { 
	uint8_t k;     
	k = xd_get_buffer();
	if (k == 0) return 0;
	pressed = ((k & 0x80) == 0);
	k &= 0x7f;
	if (k <= SW_COUNT) {
		uint8_t hid = scan_to_hid_table[hid_table_index][k - 1];
		if (hid != 0) {
			if (us_layout) {
				switch(hid) {
				case HID_J_BSLASH:
					return HID_BSLASH;	// as japanese layout
				case HID_J_UL:
					return HID_R_SHIFT;
				case HID_J_RBR_32:
					return HID_BSLASH;
				case HID_HIRAGANA:
					return HID_IME_ON;
				case HID_MUHENKAN:
					return HID_F14;
				case HID_HENKAN:
					return HID_F15;
				default:
					break;
				}
			}
			return hid;
		}
	}
	return 0;
}
// iom32u4.hにPRTIM4が定義されていない
#ifndef PRIM4
#define PRTIM4 4
#endif

// setup atmega32u4 and ports.
void init_xd87() {
	cli();
// disable Watchdog reset. To prevent stall caused by touch-1200.
	MCUSR = 0;
	wdt_disable();  

	CLKPR = 0x80;
	CLKPR = 0;    // CLKPR = 1/1
	uint8_t v = MCUCR | 0x80;
	MCUCR = v;    // disable JTAG for PF
	MCUCR = v;

//3mA ほど省エネ
	ADCSRA = ADCSRA & 0x7f;
	ACSR = ACSR | 0x80;
	PRR0 = _BV(PRTWI) | _BV(PRSPI) | _BV(PRADC);		
	PRR1 = _BV(PRTIM4) | _BV(PRTIM3) | _BV(PRUSART1);	//
  
	TCCR1A = 0; // init timers (without TC0)
	TCCR3A = 0;
	TCCR4A = 0;

// setup Ports.
	DDRB =  _BV(7) | _BV(1) | _BV(0); // PB7 = RGBLED.
	DDRC =  _BV(7);
	DDRD =  _BV(5) | _BV(3) | _BV(1) | _BV(0);
	DDRE =  _BV(2);
	DDRF =  0;
	// set INPUT_PULLUP to COLs.
	PORTB =  _BV(6) | _BV(5) | _BV(4) | _BV(3) | _BV(2);
	PORTC =  _BV(6);
	PORTD =  _BV(7) | _BV(6) | _BV(4) | _BV(2);
	PORTE =  _BV(6);
	PORTF =  _BV(7) | _BV(6) | _BV(5) | _BV(4) | _BV(1) | _BV(0);
// set output HIGH to all ROWs. BGLED off and CapsLED off.
	PORTB = PORTB | _BV(0) | _BV(1);
	PORTC = PORTC | _BV(7);
	PORTD = PORTD | _BV(0) | _BV(1) | _BV(3) | _BV(5);
	PORTE = PORTE | _BV(2);

// setup timer1 interrupt (period = 5msec)
	TCCR1A = 0;
	TCCR1B = 3; // CLKio / 64　 = 250KHz.
	TCCR1C = 0;
	TCNT1 = TIMER1_INTERVAL;
	TIMSK1 = 1; // enable Timer1 Overflow Interrupt
	memset(key_state, 0, sizeof(key_state));
	memset(last_key_state, 0, sizeof(last_key_state));
	xd_clear_buffer();
	sei();
}
