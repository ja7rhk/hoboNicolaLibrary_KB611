/**
 * hobo_nicola_ch9350if.cpp CH9350L interface module of "Hobo-nicola keyboard and adapter library".
 * Copyright (c) 2022 Takeshi Higasa, okiraku-camera.tokyo
 *
  This file is part of "Hobo-nicola keyboard and adapter library".
 *
 * "Hobo-nicola keyboard and adapter" is free software: you can redistribute it and/or modify 
 * it under the terms of the GNU General Public License as published by  
 * the Free Software Foundation, either version 3 of the License, or 
 * (at your option) any later version.
 *
 * "Hobo-nicola keyboard and adapter" is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with "Hobo-nicola keyboard and adapter".  If not, see <http://www.gnu.org/licenses/>.
*/

#include "hobo_nicola_ch9350if.h"

#define CH_SERIAL Serial1


bool ch9350if::sum_check(uint8_t datalen) {
	if (datalen < 4)
		return false;
	uint8_t sum = 0;
	uint8_t i = 1;		
	while( i < datalen - 1)
		sum += data_frame[i++];
	return (sum == data_frame[i]);		
}

// data_frame has...
// 0        1        n      n+1    n+2     
// dev_kind rep[0]...rep[n] serial chksum
// if composite device rep[0] is report_id. Assuming keyboard report_id is 1.
//
void ch9350if::parse_report(uint8_t datalen) {

	if ((data_frame[0] & 0x30) != 0x10) // not keyboard.
		return;

	uint8_t rxlen = datalen;
	if (!memcmp(data_frame, prev_data, datalen - 2))
		return; // to avoid key-repeat generated by ch9350l

	uint8_t rep_size = datalen -= 3; // datalen - (data_size + serial + sum)
	uint8_t* rep = &data_frame[1];
	uint8_t* prev_rep = &prev_data[1];
	if (composite_keyboard < 0) {	// decision of composite device or not.
		if (*rep == 0x00)
			composite_keyboard = 0; 
		else {
			if (rep[1] != 0)
				composite_keyboard = 1;
			else { // undefined.
				if (rep[2] == 0) composite_keyboard = 0;
				else composite_keyboard = 1;
			}				
		}
	}
	if (composite_keyboard == 1) {
		if (*rep != composite_report_id)	
			return;
		rep++;
		prev_rep++;
		rep_size--;
	}
  if (rep[2] == 0x01) { // roll-over error
    return;
  }
	dataframe(data_frame, rxlen);

// modifiers.
  uint8_t change = rep[0] ^ prev_rep[0];
  static const uint8_t modifier_base = 0xe0;
  if (change != 0) {
		if (!modifiers_changed(prev_rep[0], rep[0])) {
	    uint8_t mask = 1;
	    for(uint8_t i = 0; i < 8; i++, mask <<= 1)
	      if (change & mask) key_event(modifier_base + i, rep[0] & mask);
		}
  }
  for(uint8_t i = 2; i < rep_size; i++) { 
    bool cur_match = false;
    bool prev_match = false;
    for(uint8_t n = 2; n < rep_size; n++) {
      if (rep[i] == 0 || rep[i] == prev_rep[n]) cur_match = true;
      if (prev_rep[i] == 0 || prev_rep[i] == rep[n]) prev_match = true;
    }
    if (!cur_match) key_event(rep[i], true);  // detect ON key.
    if (!prev_match) key_event(prev_rep[i], false); // detect OFF key.
  }
	memcpy(prev_data, data_frame, data_size);
}

void ch9350if::reinit() {
	CH_SERIAL.end();
	_init();
	delay(10);
	reset();
	CH_SERIAL.begin(115200);
	newframe();
}

void ch9350if::ch9350_loop() {
  while(CH_SERIAL.available()) {
    uint8_t c = CH_SERIAL.read();
    if (c == 0x57 && ch_rx_state == has_none) {
      ch_rx_state = has_57;
			newframe();
    } else if (ch_rx_state == has_57) {
      if (c != 0xab) 
        ch_rx_state = has_none;
      else
        ch_rx_state = has_57ab;
    } else if (ch_rx_state == has_57ab) {
		if (c == 0x87) {	// version request
        	CH_SERIAL.write(version_frame, sizeof(version_frame));
        	ch_rx_state = has_none;
    	} else if (c == 0x84)
        	ch_rx_state = has_none;
		else if (c == 0x86) {	// disconnected.
			reinit();	
	        ch_rx_state = has_none;
    	} else {
        	ch_rx_state = has_op;
        	ch_opcode = c;
      	}
    } else if (ch_rx_state == has_op) {
		switch(ch_opcode) {
		case 0x81:
			reinit();
			break;
		case 0x83:  // data frame.
		case 0x88: 
			ch_data_length = c;
			ch_rx_length = 0;
			ch_rx_state = wait_data;
			break;
		case 0x82:  // status request 
			if (reponse_frame[led_value_index] != led_state)
				reponse_frame[led_value_index] = led_state;
			CH_SERIAL.write(reponse_frame, sizeof(reponse_frame));
      	// through
		default:
        	ch_rx_state = has_none;
        	break;
		} 
		ch_opcode = 0;
    } else if (ch_rx_state == wait_data) {
		data_frame[ch_rx_length++] = c;          
		if (ch_rx_length >= ch_data_length || ch_rx_length >= data_size) {
			ch_rx_state = has_none;
			if (sum_check(ch_rx_length)) parse_report(ch_rx_length);
		}
    }
	rx_byte(c);
  }
  delay(1);
}

void ch9350if::suspend() {
	if (rst_port != 0xff)
		digitalWrite(rst_port, HIGH);
}

void ch9350if::resume() {
	if (rst_port != 0xff) {
		digitalWrite(rst_port, LOW);
		_init();
	}
}

void ch9350if::reset() {
	if (rst_port != 0xff) {
  	digitalWrite(rst_port, HIGH);
	  digitalWrite(rst_port, LOW);
	}
}

void ch9350if::ch9350_setup() {
	if (rst_port != 0xff) 
  	pinMode(rst_port, OUTPUT);
	suspend();
	CH_SERIAL.begin(115200);
	_init();		
	resume();
//	delay(100);
}

